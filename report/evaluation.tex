%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Evaluation}\label{sec:evaluation}

\paragraph{Experiment Setup}. We ran our experiments on a physical
\texttt{Ubuntu-22.04} server with 8 Intel i5 cores and 16GB RAM. We use 
\texttt{x86\_64-linux-gnu-g++} version \texttt{11.4.0} as our \texttt{C++} compiler.
We build the \textbf{SNAP} project in debug mode
\footnote{This means that assertions and debug outputs in the code are enabled.}
and with highest possible compiler optimization  level(\texttt{-O3}), and 
enabled link-time optimization(\texttt{-flto}).
For parallel executions, we use $6$ worker threads when creating the thread
pool
\footnote{Along with the main(coordinator) thread, a total of 7 threads 
are used.}.

\paragraph{Evaluation Metrics}. We expect our implementation to achieve 
performance gains via parallelized execution. Therefore, we compare the 
\textbf{execution time} and \textbf{CPU utility rate} of our 
manually-optimized code. Ideally, a thread pool with $N$ workers should yield
a CPU utility rate of $N\times 100\%$, and a speed-up of $N$\texttt{x}. However,
we did not try to evaluate the \texttt{scalability}, a desirable property of 
parallel algorithms, because of the limitation of computation capabilities of
 our physical server.

\subsection{Community-Affiliation Graph Model}

\par Community-Affiliation Graph Model\citep{yang2012structure,yang2012community} 
is a conceptual model of community network, capturing the overlapping nature of 
network communities.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

